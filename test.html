<!DOCTYPE html>
<html>
<body>

<!-- 
    Room for 25 squares across and down at 20 pixel wide squares
    plus 26 gridlines (1 pixel wide) (internal and external)
-->
<canvas id="gridCanvas" width="526" height="526"
style="border:1px solid #000000;">
</canvas>

<script>
var canvas = document.getElementById("gridCanvas");
var ctx = canvas.getContext("2d");
var column_count = 1;
//Array index 0 is row 1 of the gridshading puzzle.
var initialHorizontalSet = [
    [2,4,1,6],
    [1, 5],
    [1,1,1,1,1,1],
    [1],
    [5,2,4,1],
    [1],
    [10,3]
];
var consecutiveBlockStartsHorizontal = [];
var numRows = initialHorizontalSet.length;

var cursorRow = 1;
var cursorCol = 10;
ctx.clearRect(0,0,canvas.width, canvas.height)
drawGrid(25,25,20);
drawCursor();
cursorDown();
drawCursor();
//populateGrid();
cursorDown();
drawCursor();

function drawCursor() { 
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.beginPath();
    ctx.lineWidth = 7;
    ctx.strokeStyle = 'black';
    strokeSquare(0.5+cursorCol*21-20,0.5+cursorRow*21-20,20);
    ctx.restore();
}

function nearest(col) {
//Return consecutive block start column number nearest to col
    num_consecutive_blocks = initialHorizontalSet[cursorRow-1].length;
    var cumulative_cols = 0;
    var limit_below = 1;
    var limit_above = 25;
    for (var i=0; i<num_consecutive_blocks; i++) {
        if (cumulative_cols < col) {
            //1+init... 1+ is for the whitespace
            cumulative_cols += (1+initialHorizontalSet[cursorRow-1][i]);
        }
        // retest cumulative_cols which may have had an increment
        if (cumulative_cols >= col) {
            limit_above= cumulative_cols;
            cumulative_cols -= (1+initialHorizontalSet[cursorRow-1][i]);
            limit_below = cumulative_cols;
            break;
        }
    }
    return ((limit_above-col)<(col-limit_below) ? limit_above:limit_below);
}            

function cursorDown() {
    if (cursorRow<25) {
        cursorRow += 1;
        cursorCol = nearest(cursorCol);
    }
}

function populateGrid() {
    ctx.save();
    ctx.fillStyle="#990099";
    var scoreSet = [];
    for (var row=0; row<25; row++) {
        scoreSet = initialHorizontalSet[row];
        consecutiveBlockStartsHorizontal[row] = [];
        column_count = 1;
        var scoreSetLength = scoreSet.length;
        for (var j=0; j<scoreSetLength; j++) {
            consecutiveRowSquares(column_count, row+1, scoreSet[j]);
            consecutiveBlockStartsHorizontal[row].push(column_count);
            column_count += scoreSet[j]+1;
        }
    }
    ctx.restore();
    ctx.save();    
}

function assert(condition, message) {
    if (!condition) {
        message = message || "Assertion Failure";
        if (typeof Error !== "undefined") {
            throw new Error(message);
        }
        throw message;
    }
}
function drawGrid(cols, rows, cell_dimension) {
    ctx.save();
    ctx.fillStyle = "#dd00dd";
    ctx.lineWidth = 1;
    assert(cols*cell_dimension+cols+1 <= canvas.width);
    assert(rows*cell_dimension+rows+1 <= canvas.height);
    for (var vline=0; vline<=cols; vline++) {
        ctx.moveTo(0.5+vline*(cell_dimension+1), 0);
        ctx.lineTo(0.5+vline*(cell_dimension+1), canvas.height);
        ctx.stroke();
    }
    for (var hline=0; hline<=rows; hline++) {
        ctx.moveTo(0, 0.5+hline*(cell_dimension+1));
        ctx.lineTo(canvas.width, 0.5+hline*(cell_dimension+1));
        ctx.stroke();
    }
    ctx.restore();
}
function consecutiveRowSquares(column, row, count) {
    assert(row<=25);
    assert(column+count<25+1);
    for (var i=0; i<count; i++) {
        fillSquare(column+i, row);
    }
}

function strokeSquare(x, y, length) {
    ctx.strokeRect(x, y, length, length);
}

function fillSquare(col, row) {
    ctx.fillRect(0.5+21*(col-1), 0.5+21*(row-1), 20.5, 20.5);
}
</script>

</body>
</html>

